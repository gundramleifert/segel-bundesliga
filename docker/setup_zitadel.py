#!/usr/bin/env python3
"""
Zitadel Setup Script for Segel-Bundesliga

This script automatically configures Zitadel with:
- Project "segel-bundesliga"
- Roles (ADMIN, BLOG_WRITE, BLOG_PUBLISH, SPONSOR_MANAGE, PAIRING_EXECUTE, PAIRING_VIEW, INTERNAL_ACCESS)
- Frontend OIDC Application
- Simplified password policy (no symbols required)
- Disabled 2FA requirement
- Admin user role assignment
- Test user for E2E tests
- Auto-updates frontend .env.local

Prerequisites:
    1. Docker services running: docker compose -f docker-compose.dev.yml up -d
    2. Zitadel healthy: curl http://localhost:8081/debug/healthz
    3. PAT file exists: zitadel-data/admin.pat (auto-generated by Zitadel)

Usage:
    # Full setup (first time or after reset)
    uv run python setup_zitadel.py

    # Just update frontend config (after Zitadel reset)
    uv run python setup_zitadel.py --sync-frontend

    # Add a new user
    uv run python setup_zitadel.py --add-user USERNAME PASSWORD

    # Reset a user's password
    uv run python setup_zitadel.py --reset-password USERNAME NEW_PASSWORD

    # With custom PAT or URL
    uv run python setup_zitadel.py --pat YOUR_PAT_TOKEN
    uv run python setup_zitadel.py --url http://localhost:8081

Output:
    - zitadel.env: Environment variables for backend/frontend configuration
    - ../frontend/.env.local: Updated with new Zitadel Client ID

Users (after setup):
    Admin (with ADMIN role):
        Username: admin
        Password: test1234

    Test User (without ADMIN role, for E2E tests):
        Username: testuser
        Password: test1234

    Zitadel System Admin (for console):
        URL: http://localhost:8081/ui/console
        Username: admin@zitadel.localhost
        Password: Admin123!

Troubleshooting:
    - Login redirects back without error: Password policy or 2FA issue, re-run setup
    - "App not found" error: Frontend has old Client ID, run --sync-frontend
    - Password change required: User needs password reset with --reset-password
"""

import argparse
import json
import shutil
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional
import urllib.request
import urllib.error


class ZitadelSetup:
    def __init__(self, base_url: str, pat: str):
        self.base_url = base_url.rstrip('/')
        self.pat = pat
        self.project_id: Optional[str] = None
        self.frontend_client_id: Optional[str] = None

    def _request(self, method: str, endpoint: str, data: Optional[dict] = None) -> dict:
        """Make HTTP request to Zitadel API."""
        url = f"{self.base_url}{endpoint}"
        headers = {
            "Authorization": f"Bearer {self.pat}",
            "Content-Type": "application/json",
        }

        body = json.dumps(data).encode('utf-8') if data else None
        req = urllib.request.Request(url, data=body, headers=headers, method=method)

        try:
            with urllib.request.urlopen(req) as response:
                return json.loads(response.read().decode('utf-8'))
        except urllib.error.HTTPError as e:
            error_body = e.read().decode('utf-8')
            print(f"  Error {e.code}: {error_body}")
            return {"error": True, "code": e.code, "message": error_body}
        except Exception as e:
            print(f"  Request failed: {e}")
            return {"error": True, "message": str(e)}

    def check_health(self) -> bool:
        """Check if Zitadel is healthy."""
        try:
            req = urllib.request.Request(f"{self.base_url}/debug/healthz")
            with urllib.request.urlopen(req, timeout=5) as response:
                return response.read().decode('utf-8') == "ok"
        except Exception:
            return False

    def create_project(self, name: str = "segel-bundesliga") -> Optional[str]:
        """Create a new project."""
        print(f"\n[1/6] Creating project '{name}'...")

        # Retry logic for initial connection (management API may not be ready)
        max_retries = 5
        for attempt in range(max_retries):
            result = self._request("POST", "/management/v1/projects/_search", {
                "queries": [{"nameQuery": {"name": name, "method": "TEXT_QUERY_METHOD_EQUALS"}}]
            })
            if not result.get("error") or result.get("code") != 503:
                break
            if attempt < max_retries - 1:
                wait_time = 5 * (attempt + 1)
                print(f"  Management API not ready, retrying in {wait_time}s...")
                time.sleep(wait_time)

        # First, check if project already exists
        result = self._request("POST", "/management/v1/projects/_search", {
            "queries": [{"nameQuery": {"name": name, "method": "TEXT_QUERY_METHOD_EQUALS"}}]
        })

        if result.get("result"):
            self.project_id = result["result"][0]["id"]
            print(f"  Project already exists: {self.project_id}")
            return self.project_id

        # Create new project
        result = self._request("POST", "/management/v1/projects", {
            "name": name,
            "projectRoleAssertion": True,
            "projectRoleCheck": True
        })

        if "id" in result:
            self.project_id = result["id"]
            print(f"  Created project: {self.project_id}")
            return self.project_id
        else:
            print(f"  Failed to create project")
            return None

    def create_roles(self) -> bool:
        """Create project roles."""
        print("\n[2/6] Creating roles...")

        if not self.project_id:
            print("  Error: No project ID")
            return False

        roles = [
            ("ADMIN", "Administrator with full access"),
            ("BLOG_WRITE", "Can create and edit blog posts"),
            ("BLOG_PUBLISH", "Can publish blog posts"),
            ("PAIRING_EXECUTE", "Can run pairing optimizations"),
            ("PAIRING_VIEW", "Can view pairing results"),
            ("INTERNAL_ACCESS", "Can access internal content"),
        ]

        for role_key, description in roles:
            result = self._request("POST", f"/management/v1/projects/{self.project_id}/roles", {
                "roleKey": role_key,
                "displayName": role_key,
                "group": "segel-bundesliga"
            })

            if result.get("error"):
                if "already exists" in str(result.get("message", "")).lower():
                    print(f"  Role exists: {role_key}")
                else:
                    print(f"  Failed: {role_key}")
            else:
                print(f"  Created: {role_key}")

        return True

    def create_frontend_app(self) -> Optional[str]:
        """Create OIDC application for frontend."""
        print("\n[3/6] Creating frontend OIDC application...")

        if not self.project_id:
            print("  Error: No project ID")
            return None

        # Check if app already exists
        result = self._request("POST", f"/management/v1/projects/{self.project_id}/apps/_search", {})

        for app in result.get("result", []):
            if app.get("name") == "segel-bundesliga-frontend":
                self.frontend_client_id = app.get("oidcConfig", {}).get("clientId")
                app_id = app.get("id")

                # Update redirect URIs to include Swagger if missing
                current_uris = app.get("oidcConfig", {}).get("redirectUris", [])
                swagger_uri = "http://localhost:8080/swagger-ui/oauth2-redirect.html"
                if swagger_uri not in current_uris:
                    print(f"  Adding Swagger redirect URI to existing app...")
                    new_uris = current_uris + [swagger_uri]
                    self._request("PUT", f"/management/v1/projects/{self.project_id}/apps/{app_id}/oidc_config", {
                        "redirectUris": new_uris,
                        "postLogoutRedirectUris": app.get("oidcConfig", {}).get("postLogoutRedirectUris", [])
                    })

                print(f"  App already exists, Client ID: {self.frontend_client_id}")
                return self.frontend_client_id

        # Create new app
        result = self._request("POST", f"/management/v1/projects/{self.project_id}/apps/oidc", {
            "name": "segel-bundesliga-frontend",
            "redirectUris": [
                "http://localhost:3000/callback",
                "http://localhost:3000/silent-refresh.html",
                "http://localhost:8080/swagger-ui/oauth2-redirect.html"
            ],
            "postLogoutRedirectUris": [
                "http://localhost:3000"
            ],
            "responseTypes": ["OIDC_RESPONSE_TYPE_CODE"],
            "grantTypes": [
                "OIDC_GRANT_TYPE_AUTHORIZATION_CODE",
                "OIDC_GRANT_TYPE_REFRESH_TOKEN"
            ],
            "appType": "OIDC_APP_TYPE_WEB",
            "authMethodType": "OIDC_AUTH_METHOD_TYPE_NONE",
            "accessTokenType": "OIDC_TOKEN_TYPE_JWT",
            "idTokenRoleAssertion": True,
            "idTokenUserinfoAssertion": True,
            "accessTokenRoleAssertion": True,
            "devMode": True
        })

        if "clientId" in result:
            self.frontend_client_id = result["clientId"]
            print(f"  Created app, Client ID: {self.frontend_client_id}")
            return self.frontend_client_id
        else:
            print(f"  Failed to create app")
            return None

    def simplify_password_policy(self) -> bool:
        """Simplify password policy for development (no symbols required)."""
        print("\n[4/8] Simplifying password policy...")

        result = self._request("PUT", "/admin/v1/policies/password/complexity", {
            "minLength": 8,
            "hasUppercase": False,
            "hasLowercase": False,
            "hasNumber": False,
            "hasSymbol": False
        })

        if result.get("error"):
            print(f"  Warning: Could not update password policy: {result.get('message', 'Unknown error')}")
        else:
            print("  Password policy simplified (min 8 chars, no special requirements)")

        return True

    def disable_email_verification(self) -> bool:
        """Disable email verification and 2FA requirements."""
        print("\n[5/8] Configuring login policy...")

        # Update default login policy
        result = self._request("PUT", "/admin/v1/policies/login", {
            "allowUsernamePassword": True,
            "allowRegister": False,
            "allowExternalIdp": False,
            "forceMfa": False,
            "forceMfaLocalOnly": False,
            "passwordlessType": "PASSWORDLESS_TYPE_NOT_ALLOWED",
            "hidePasswordReset": False,
            "ignoreUnknownUsernames": False,
            "defaultRedirectUri": "",
            "allowDomainDiscovery": False,
            "disableLoginWithEmail": False,
            "disableLoginWithPhone": True,
            # Disable 2FA setup prompt by setting skip lifetime to 0
            "mfaInitSkipLifetime": "0s",
            "passwordCheckLifetime": "864000s",
            "externalLoginCheckLifetime": "864000s",
            "secondFactorCheckLifetime": "64800s",
            "multiFactorCheckLifetime": "43200s"
        })

        if result.get("error"):
            print(f"  Warning: Could not update login policy: {result.get('message', 'Unknown error')}")
        else:
            print("  Login policy updated (no forced MFA, no email verification)")

        return True

    def _create_user_with_role(self, username: str, password: str, first_name: str, last_name: str, role: str) -> bool:
        """Create a user and grant a role."""
        # Check if user already exists
        result = self._request("POST", "/management/v1/users/_search", {
            "queries": [{"userNameQuery": {"userName": username, "method": "TEXT_QUERY_METHOD_EQUALS"}}]
        })

        users = result.get("result", [])
        if users:
            user_id = users[0]["id"]
            print(f"  User '{username}' already exists: {user_id}")
        else:
            # Create user
            result = self._request("POST", "/management/v1/users/human/_import", {
                "userName": username,
                "profile": {
                    "firstName": first_name,
                    "lastName": last_name
                },
                "email": {
                    "email": f"{username}@localhost",
                    "isEmailVerified": True
                },
                "password": password,
                "passwordChangeRequired": False
            })

            if "userId" in result:
                user_id = result["userId"]
                print(f"  Created user '{username}': {user_id}")
            else:
                print(f"  Failed to create user '{username}': {result}")
                return False

        # Grant role
        result = self._request("POST", f"/management/v1/users/{user_id}/grants", {
            "projectId": self.project_id,
            "roleKeys": [role]
        })

        if result.get("error"):
            if "already exists" in str(result.get("message", "")).lower():
                print(f"  Role '{role}' already granted to '{username}'")
            else:
                print(f"  Warning: Could not grant role: {result.get('message')}")
        else:
            print(f"  Granted '{role}' role to '{username}'")

        return True

    def create_users(self) -> bool:
        """Create admin and test users."""
        print("\n[6/8] Creating users...")

        if not self.project_id:
            print("  Error: No project ID")
            return False

        # Create admin user with simple password
        self._create_user_with_role("admin", "test1234", "Admin", "User", "ADMIN")

        # Create test user for E2E tests (without admin role)
        self._create_user_with_role("testuser", "test1234", "Test", "User", "INTERNAL_ACCESS")

        return True

    def grant_admin_role(self) -> bool:
        """Grant ADMIN role to admin user."""
        print("\n[7/8] Granting ADMIN role to admin user...")

        if not self.project_id:
            print("  Error: No project ID")
            return False

        # Find admin user (Zitadel creates as admin@zitadel.localhost)
        result = self._request("POST", "/management/v1/users/_search", {
            "queries": [{"userNameQuery": {"userName": "admin@zitadel.localhost", "method": "TEXT_QUERY_METHOD_EQUALS"}}]
        })

        users = result.get("result", [])
        if not users:
            print("  Admin user not found")
            return False

        admin_user_id = users[0]["id"]
        print(f"  Found admin user: {admin_user_id}")

        # Grant role
        result = self._request("POST", f"/management/v1/users/{admin_user_id}/grants", {
            "projectId": self.project_id,
            "roleKeys": ["ADMIN"]
        })

        if result.get("error"):
            if "already exists" in str(result.get("message", "")).lower():
                print("  Role grant already exists")
            else:
                print(f"  Failed to grant role")
                return False
        else:
            print("  Granted ADMIN role to admin user")

        return True

    def save_config(self, output_path: Path) -> bool:
        """Save configuration to .env file."""
        print("\n[8/8] Saving configuration...")

        config = f"""# Zitadel Configuration (auto-generated)
# Generated by setup_zitadel.py

# Backend Configuration
ZITADEL_ISSUER={self.base_url}
ZITADEL_PROJECT_ID={self.project_id}

# Frontend Configuration
VITE_ZITADEL_ISSUER={self.base_url}
VITE_ZITADEL_CLIENT_ID={self.frontend_client_id}
VITE_ZITADEL_PROJECT_ID={self.project_id}
"""

        try:
            output_path.write_text(config)
            print(f"  Saved to: {output_path}")
            return True
        except Exception as e:
            print(f"  Failed to save: {e}")
            return False

    def sync_frontend_config(self) -> bool:
        """Update frontend .env.local and backend application.yml with current Zitadel configuration."""
        print("\nSyncing configuration...")

        # First, get current project and app info
        if not self.project_id:
            # Try to find existing project
            result = self._request("POST", "/management/v1/projects/_search", {
                "queries": [{"nameQuery": {"name": "segel-bundesliga", "method": "TEXT_QUERY_METHOD_EQUALS"}}]
            })
            if result.get("result"):
                self.project_id = result["result"][0]["id"]
            else:
                print("  Error: Project not found. Run full setup first.")
                return False

        if not self.frontend_client_id:
            # Try to find existing app
            result = self._request("POST", f"/management/v1/projects/{self.project_id}/apps/_search", {})
            for app in result.get("result", []):
                if app.get("name") == "segel-bundesliga-frontend":
                    self.frontend_client_id = app.get("oidcConfig", {}).get("clientId")
                    break
            if not self.frontend_client_id:
                print("  Error: Frontend app not found. Run full setup first.")
                return False

        # Update frontend .env.local
        frontend_env_path = Path(__file__).parent.parent / "frontend" / ".env.local"
        env_content = f"""VITE_ZITADEL_ISSUER={self.base_url}
VITE_ZITADEL_CLIENT_ID={self.frontend_client_id}
VITE_ZITADEL_PROJECT_ID={self.project_id}
"""
        try:
            frontend_env_path.write_text(env_content)
            print(f"  Updated frontend: {frontend_env_path}")
            print(f"    Client ID: {self.frontend_client_id}")
            print(f"    Project ID: {self.project_id}")
        except Exception as e:
            print(f"  Failed to update frontend config: {e}")
            return False

        # Update backend application.yml
        backend_yml_path = Path(__file__).parent.parent / "backend" / "src" / "main" / "resources" / "application.yml"
        try:
            yml_content = backend_yml_path.read_text()

            # Update project-id line using regex
            import re
            updated_content = re.sub(
                r'(project-id:\s*\$\{ZITADEL_PROJECT_ID:)[0-9]+(\})',
                f'\\g<1>{self.project_id}\\2',
                yml_content
            )

            if updated_content != yml_content:
                backend_yml_path.write_text(updated_content)
                print(f"  Updated backend: {backend_yml_path}")
                print(f"    Project ID: {self.project_id}")
            else:
                print(f"  Backend already up-to-date: {backend_yml_path}")

        except Exception as e:
            print(f"  Failed to update backend config: {e}")
            return False

        print("\n  NOTE: Restart backend and frontend for changes to take effect!")
        return True

    def add_user(self, username: str, password: str, role: str = "ADMIN") -> bool:
        """Add a new user with the specified role."""
        print(f"\nAdding user '{username}'...")

        # Get project ID if not set
        if not self.project_id:
            result = self._request("POST", "/management/v1/projects/_search", {
                "queries": [{"nameQuery": {"name": "segel-bundesliga", "method": "TEXT_QUERY_METHOD_EQUALS"}}]
            })
            if result.get("result"):
                self.project_id = result["result"][0]["id"]
            else:
                print("  Error: Project not found. Run full setup first.")
                return False

        return self._create_user_with_role(username, password, username.title(), "User", role)

    def reset_password(self, username: str, new_password: str) -> bool:
        """Reset a user's password without requiring change on next login."""
        print(f"\nResetting password for '{username}'...")

        # Find user
        result = self._request("POST", "/management/v1/users/_search", {
            "queries": [{"userNameQuery": {"userName": username, "method": "TEXT_QUERY_METHOD_EQUALS"}}]
        })

        users = result.get("result", [])
        if not users:
            print(f"  Error: User '{username}' not found")
            return False

        user_id = users[0]["id"]

        # Set new password
        result = self._request("POST", f"/management/v1/users/{user_id}/password", {
            "password": new_password,
            "noChangeRequired": True
        })

        if result.get("error"):
            print(f"  Error: {result.get('message', 'Unknown error')}")
            return False

        print(f"  Password reset successfully for '{username}'")
        return True

    def run(self) -> bool:
        """Run full Zitadel setup."""
        print("=" * 50)
        print("Zitadel Setup for Segel-Bundesliga")
        print("=" * 50)

        # 1. Create project
        self.project_id = self.create_project()
        if not self.project_id:
            return False

        # 2. Create roles
        if not self.create_roles():
            return False

        # 3. Create frontend app
        self.frontend_client_id = self.create_frontend_app()
        if not self.frontend_client_id:
            return False

        # 4. Simplify password policy
        if not self.simplify_password_policy():
            return False

        # 5. Disable email verification
        if not self.disable_email_verification():
            return False

        # 6. Create users
        if not self.create_users():
            return False

        # 7. Grant admin role
        if not self.grant_admin_role():
            return False

        # 8. Save config
        script_dir = Path(__file__).parent
        if not self.save_config(script_dir / "zitadel.env"):
            return False

        # 9. Sync frontend config
        if not self.sync_frontend_config():
            return False

        print("\n" + "=" * 50)
        print("Setup completed successfully!")
        print("=" * 50)
        return True

    def list_users(self) -> bool:
        """List all users."""
        print("\nListing users...")

        result = self._request("POST", "/management/v1/users/_search", {})

        users = result.get("result", [])
        if not users:
            print("  No users found")
            return True

        print(f"  Found {len(users)} users:")
        for user in users:
            username = user.get("userName", "unknown")
            state = user.get("state", "unknown").replace("USER_STATE_", "")
            user_type = "human" if "human" in user else "machine"
            print(f"    - {username} ({user_type}, {state})")

        return True


def reset_zitadel() -> bool:
    """Complete reset of Zitadel: stop services, clear data, restart, run setup."""
    script_dir = Path(__file__).parent
    zitadel_data_dir = script_dir / "zitadel-data"
    compose_file = script_dir / "docker-compose.dev.yml"

    print("=" * 50)
    print("Zitadel Complete Reset")
    print("=" * 50)

    # Step 1: Stop Docker services
    print("\n[1/6] Stopping Docker services...")
    result = subprocess.run(
        ["docker", "compose", "-f", str(compose_file), "down"],
        cwd=script_dir,
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        print(f"  Warning: {result.stderr}")
    else:
        print("  Services stopped")

    # Step 2: Clear zitadel-data directory
    print("\n[2/6] Clearing zitadel-data...")
    if zitadel_data_dir.exists():
        try:
            for item in zitadel_data_dir.iterdir():
                if item.is_file():
                    item.unlink()
                elif item.is_dir():
                    shutil.rmtree(item)
            print("  Cleared zitadel-data/")
        except PermissionError:
            print("  ERROR: Permission denied. Try running:")
            print(f"    sudo rm -rf {zitadel_data_dir}/*")
            print("  Then run this script again without --reset")
            return False
    else:
        zitadel_data_dir.mkdir(parents=True)
        print("  Created zitadel-data/")

    # Step 3: Start postgres only to reset database
    print("\n[3/6] Resetting Zitadel database...")
    subprocess.run(
        ["docker", "compose", "-f", str(compose_file), "up", "-d", "postgres"],
        cwd=script_dir,
        capture_output=True
    )
    time.sleep(3)  # Wait for postgres to start

    # Drop zitadel database and user
    drop_commands = [
        ["docker", "compose", "-f", str(compose_file), "exec", "-T", "postgres",
         "psql", "-U", "postgres", "-c", "DROP DATABASE IF EXISTS zitadel;"],
        ["docker", "compose", "-f", str(compose_file), "exec", "-T", "postgres",
         "psql", "-U", "postgres", "-c", "DROP USER IF EXISTS zitadel;"]
    ]
    for cmd in drop_commands:
        subprocess.run(cmd, cwd=script_dir, capture_output=True)
    print("  Database reset")

    # Step 4: Start all services
    print("\n[4/6] Starting all services...")
    subprocess.run(
        ["docker", "compose", "-f", str(compose_file), "up", "-d"],
        cwd=script_dir,
        capture_output=True
    )
    print("  Services starting...")

    # Step 5: Wait for Zitadel to be ready
    print("\n[5/6] Waiting for Zitadel to be ready...")
    base_url = "http://localhost:8081"
    max_attempts = 60
    for i in range(max_attempts):
        try:
            req = urllib.request.Request(f"{base_url}/debug/healthz")
            with urllib.request.urlopen(req, timeout=2) as response:
                if response.read().decode('utf-8') == "ok":
                    print(f"  Zitadel ready after {i * 2} seconds")
                    break
        except Exception:
            pass
        if i < max_attempts - 1:
            print(f"  Waiting... ({i * 2}s)", end="\r")
            time.sleep(2)
    else:
        print("  ERROR: Zitadel did not become ready in time")
        return False

    # Step 6: Run setup
    print("\n[6/6] Running setup...")
    pat_file = zitadel_data_dir / "admin.pat"

    # Wait a bit more for PAT file to be written
    for _ in range(10):
        if pat_file.exists():
            break
        time.sleep(1)

    if not pat_file.exists():
        print(f"  ERROR: PAT file not found: {pat_file}")
        return False

    # Wait additional time for Zitadel management API to be ready
    print("  Waiting for management API to be ready...")
    time.sleep(10)

    pat = pat_file.read_text().strip()
    setup = ZitadelSetup(base_url, pat)
    return setup.run()


def main():
    parser = argparse.ArgumentParser(
        description="Setup and manage Zitadel for Segel-Bundesliga",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  uv run python setup_zitadel.py                          # Full setup
  uv run python setup_zitadel.py --reset                  # Complete reset and setup
  uv run python setup_zitadel.py --sync-frontend          # Update frontend config only
  uv run python setup_zitadel.py --add-user john test123  # Add new user
  uv run python setup_zitadel.py --reset-password john newpass  # Reset password
  uv run python setup_zitadel.py --list-users             # List all users
"""
    )
    parser.add_argument("--url", default="http://localhost:8081", help="Zitadel URL")
    parser.add_argument("--pat", help="Personal Access Token (reads from zitadel-data/admin.pat if not provided)")

    # Action arguments (mutually exclusive)
    action_group = parser.add_mutually_exclusive_group()
    action_group.add_argument("--reset", action="store_true",
                              help="Complete reset: stop services, clear data, restart, run setup")
    action_group.add_argument("--sync-frontend", action="store_true",
                              help="Only sync frontend .env.local with current Zitadel config")
    action_group.add_argument("--add-user", nargs=2, metavar=("USERNAME", "PASSWORD"),
                              help="Add a new user with ADMIN role")
    action_group.add_argument("--reset-password", nargs=2, metavar=("USERNAME", "PASSWORD"),
                              help="Reset a user's password")
    action_group.add_argument("--list-users", action="store_true",
                              help="List all users")

    args = parser.parse_args()

    # Handle reset separately (doesn't need PAT initially)
    if args.reset:
        success = reset_zitadel()
        sys.exit(0 if success else 1)

    # Get PAT for other operations
    pat = args.pat
    if not pat:
        pat_file = Path(__file__).parent / "zitadel-data" / "admin.pat"
        if pat_file.exists():
            pat = pat_file.read_text().strip()
            print(f"Using PAT from: {pat_file}")
        else:
            print(f"Error: No PAT provided and {pat_file} not found")
            print("Run 'docker compose up' first to generate the PAT")
            print("Or use --reset to do a complete reset")
            sys.exit(1)

    # Create setup instance
    setup = ZitadelSetup(args.url, pat)

    # Check health first
    if not setup.check_health():
        print("Error: Zitadel is not healthy or not reachable")
        sys.exit(1)

    # Execute requested action
    if args.sync_frontend:
        success = setup.sync_frontend_config()
    elif args.add_user:
        username, password = args.add_user
        success = setup.add_user(username, password)
    elif args.reset_password:
        username, password = args.reset_password
        success = setup.reset_password(username, password)
    elif args.list_users:
        success = setup.list_users()
    else:
        # Full setup
        success = setup.run()

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
